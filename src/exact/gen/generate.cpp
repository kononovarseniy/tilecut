#include <cfenv>
#include <cstddef>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <limits>
#include <source_location>

#include <boost/program_options.hpp>

#include <mpfr.h>

#include <common/fixed.hpp>

namespace ka
{

inline namespace
{
/// @brief Prevents underflows.
constexpr f64 g_min_regular_grid_input_coordinate = 0.005;
/// @brief Limits absolute error.
constexpr f64 g_max_regular_grid_input_coordinate = 0x1p25;
/// @brief WGS 84 equator in meters.
constexpr f64 g_epsg_3857_equator = 2.0 * 20037508.34;
/// @brief Max length of the equator in target projections.
constexpr f64 g_max_grid_size = 0x1p32;

/// @brief u.
constexpr f64 unit_roundoff = 0x1p-53;

struct Constants final
{
    /// Minimal allowed step of the regular grid.
    /// @brief RoundDown(g_epsg_3857_equator / g_max_grid_size)
    std::string min_grid_step;
    /// @brief RoundUp(21 * max_input_coordinate * unit_roundoff / min_grid_step)
    std::string min_reliable_fractional_part;
    /// @brief RoundDown(1.0 - min_reliable_fractional_part)
    std::string max_reliable_fractional_part;
};

[[nodiscard]] std::string to_hex(const mpfr_t value)
{
    std::array<char, 32> data;
    mpfr_sprintf(data.data(), "%Ra", value);
    return data.data();
}

[[nodiscard]] std::string to_hex(const long double value)
{
    std::array<char, 32> data;
    mpfr_sprintf(data.data(), "%La", value);
    return data.data();
}

[[nodiscard]] Constants compute_constants()
{
    mpfr_t min_grid_step;
    mpfr_init2(min_grid_step, 53);
    mpfr_set_d(min_grid_step, g_epsg_3857_equator, MPFR_RNDD);
    mpfr_div_d(min_grid_step, min_grid_step, g_max_grid_size, MPFR_RNDD);
    const auto min_step = to_hex(min_grid_step);

    mpfr_t reliable_fractional_part;
    mpfr_init2(reliable_fractional_part, 53);
    mpfr_set_d(reliable_fractional_part, g_max_regular_grid_input_coordinate, MPFR_RNDU);
    mpfr_mul_ui(reliable_fractional_part, reliable_fractional_part, 21, MPFR_RNDU);
    mpfr_mul_d(reliable_fractional_part, reliable_fractional_part, unit_roundoff, MPFR_RNDU);
    mpfr_div(reliable_fractional_part, reliable_fractional_part, min_grid_step, MPFR_RNDU);
    const auto min_reliable = to_hex(reliable_fractional_part);
    mpfr_ui_sub(reliable_fractional_part, 1.0, reliable_fractional_part, MPFR_RNDD);
    const auto max_reliable = to_hex(reliable_fractional_part);

    mpfr_clears(min_grid_step, reliable_fractional_part, nullptr);

    return {
        .min_grid_step = min_step,
        .min_reliable_fractional_part = min_reliable,
        .max_reliable_fractional_part = max_reliable,
    };
}

constexpr auto begin_namespace_template = R"(
namespace {}
{{
)";

constexpr auto end_namespace_template = R"(
}} // namespace {}
)";

constexpr auto constant_template = R"(
/// {}
constexpr f64 {} = {};
)";

void generate_constants_cpp(const std::filesystem::path & output_file)
{
    const auto constants = compute_constants();

    std::ofstream output(output_file);
    output
        << std::format("/// This file is generated by {}.", std::source_location::current().file_name()) << std::endl
        << "/// Don't edit it manually." << std::endl
        << std::endl
        << "#pragma once" << std::endl
        << std::endl
        << "#include <common/fixed.hpp>" << std::endl;
    output << std::format(begin_namespace_template, "ka");

    output << std::format(
        constant_template,
        "Minimal allowed absolute value of input coordinates.",
        "g_min_regular_grid_input_coordinate",
        to_hex(g_min_regular_grid_input_coordinate));
    output << std::format(
        constant_template,
        "Maximal allowed absolute value of input coordinates.",
        "g_max_regular_grid_input_coordinate",
        to_hex(g_max_regular_grid_input_coordinate));
    output << std::format(
        constant_template,
        "Minimal allowed step of the regular grid.",
        "g_min_grid_step",
        constants.min_grid_step);

    output << std::format(begin_namespace_template, "column_border_intersecion_detail");

    output << std::format(
        constant_template,
        "Smaller values of the fractional part do not guarantee correct rounding in the column_border_intersecion.",
        "g_min_reliable_fractional_part",
        constants.min_reliable_fractional_part);
    output << std::format(
        constant_template,
        "Larger values of the fractional part do not guarantee correct rounding in the column_border_intersecion.",
        "g_max_reliable_fractional_part",
        constants.max_reliable_fractional_part);

    output << std::format(end_namespace_template, "column_border_intersecion_detail");

    output << std::format(end_namespace_template, "ka");
}

} // namespace

} // namespace ka

int main(int argc, char * argv[])
{
    using namespace ka;
    namespace po = boost::program_options;

    po::options_description desc("Allowed options");
    desc.add_options()("help", "produce help message");
    desc.add_options()("output", po::value<std::filesystem::path>(), "output file");

    po::variables_map variables;
    po::store(po::parse_command_line(argc, argv, desc), variables);
    po::notify(variables);

    if (variables.count("help"))
    {
        std::cout << desc << std::endl;
        return EXIT_FAILURE;
    }

    generate_constants_cpp(variables["output"].as<std::filesystem::path>());

    return EXIT_SUCCESS;
}
