#include <cfenv>
#include <cstddef>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <limits>
#include <source_location>

#include <boost/program_options.hpp>

#include <mpfr.h>

#include <ka/common/fixed.hpp>

namespace ka
{

inline namespace
{
/// @brief Prevents underflows.
constexpr f64 g_min_regular_grid_input_coordinate = 0.005;
/// @brief Limits absolute error.
constexpr f64 g_max_regular_grid_input_coordinate = 0x1p25;
/// @brief WGS 84 equator in meters.
constexpr f64 g_epsg_3857_equator = 2.0 * 20037508.34;
/// @brief Max length of the equator in target projections.
constexpr f64 g_max_grid_size = 0x1p32;

/// @brief u.
constexpr f64 unit_roundoff = 0x1p-53;

struct Constants final
{
    /// Minimal allowed step of the regular grid.
    /// @brief RoundDown(g_epsg_3857_equator / g_max_grid_size)
    std::string min_grid_step;
    /// @brief RoundUp(21 * max_input_coordinate * unit_roundoff / min_grid_step)
    std::string min_reliable_fractional_part;
    /// @brief RoundDown(1.0 - min_reliable_fractional_part)
    std::string max_reliable_fractional_part;
};

[[nodiscard]] std::string to_hex(const mpfr_t value)
{
    std::array<char, 32> data;
    mpfr_sprintf(data.data(), "%Ra", value);
    return data.data();
}

[[nodiscard]] std::string to_hex(const long double value)
{
    std::array<char, 32> data;
    mpfr_sprintf(data.data(), "%La", value);
    return data.data();
}

[[nodiscard]] Constants compute_constants()
{
    mpfr_t min_grid_step;
    mpfr_init2(min_grid_step, 53);
    mpfr_set_d(min_grid_step, g_epsg_3857_equator, MPFR_RNDD);
    mpfr_div_d(min_grid_step, min_grid_step, g_max_grid_size, MPFR_RNDD);
    const auto min_step = to_hex(min_grid_step);

    mpfr_t reliable_fractional_part;
    mpfr_init2(reliable_fractional_part, 53);
    mpfr_set_d(reliable_fractional_part, g_max_regular_grid_input_coordinate, MPFR_RNDU);
    mpfr_mul_ui(reliable_fractional_part, reliable_fractional_part, 21, MPFR_RNDU);
    mpfr_mul_d(reliable_fractional_part, reliable_fractional_part, unit_roundoff, MPFR_RNDU);
    mpfr_div(reliable_fractional_part, reliable_fractional_part, min_grid_step, MPFR_RNDU);
    const auto min_reliable = to_hex(reliable_fractional_part);
    mpfr_ui_sub(reliable_fractional_part, 1.0, reliable_fractional_part, MPFR_RNDD);
    const auto max_reliable = to_hex(reliable_fractional_part);

    mpfr_clears(min_grid_step, reliable_fractional_part, nullptr);

    return {
        .min_grid_step = min_step,
        .min_reliable_fractional_part = min_reliable,
        .max_reliable_fractional_part = max_reliable,
    };
}

void generate_constants_cpp(const std::filesystem::path & output_file)
{
    const auto constants = compute_constants();

    std::ofstream output(output_file);
    const auto write = [&]<typename... Args>(std::format_string<Args...> fmt = "", Args &&... args)
    {
        output << std::format(fmt, std::forward<Args>(args)...) << std::endl;
    };
    write("/// This file is generated by {}.", std::source_location::current().file_name());
    write("/// Don't edit it manually.");
    write();
    write("#pragma once");
    write();
    write("#include <ka/exact/GridParameters.hpp>");
    write();
    write("namespace ka");
    write("{{");
    write();
    write("constexpr GridParameters g_embedded_grid = {{");
    write("    .cell_size = {},", constants.min_grid_step);
    write("    .desired_cell_size = {},", constants.min_grid_step);
    write("    .min_input = {},", to_hex(g_min_regular_grid_input_coordinate));
    write("    .max_input = {},", to_hex(g_max_regular_grid_input_coordinate));
    write("    .column_border_intersecion = {{");
    write("        .min_reliable_fractional_part = {},", constants.min_reliable_fractional_part);
    write("        .max_reliable_fractional_part = {},", constants.max_reliable_fractional_part);
    write("    }},");
    write("}};");
    write();
    write("}} // namespace ka");
}

} // namespace

} // namespace ka

int main(int argc, char * argv[])
{
    using namespace ka;
    namespace po = boost::program_options;

    po::options_description desc("Allowed options");
    desc.add_options()("help", "produce help message");
    desc.add_options()("output", po::value<std::filesystem::path>(), "output file");

    po::variables_map variables;
    po::store(po::parse_command_line(argc, argv, desc), variables);
    po::notify(variables);

    if (variables.count("help"))
    {
        std::cout << desc << std::endl;
        return EXIT_FAILURE;
    }

    generate_constants_cpp(variables["output"].as<std::filesystem::path>());

    return EXIT_SUCCESS;
}
